"strict mode"

/* This is a fork of Chart.js
 * http://chartjs.org/
 *
 * Copyright 2013 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */

/*The chart calculator acts a wrapper around window.Chart. It allows arrays to be
passed in place of individual data points. The median (in the case of Box plots) or
mean (in other cases) is calculated, along with appropriate error bars, and all of this 
is passed along to the main Chart object.
It is not necessary to use the Chart calculator, but in that case data points and actual
error info (if desired) must be passed directly to the Chart object.
*/
window.ChartCalculator = function(context) {
	
	this.Box = function(data, options) {
		for (var x = 0; x < data.datasets.length; x++) {
			for (var y = 0; y < data.datasets[x].data.length; y++) {
				var values = data.datasets[x].data[y]
				values.sort(function(a, b){return a - b});
				var n = values.length;
				//get the minimum value
				var q0 = values[0]
				//get the median (q2) value
				var q2n = Math.floor(n / 2);
				if (n % 2 == 1) { //odd sample size
					var q2 = values[q2n];
				} else {
					var q2 = (values[q2n] + values[q2n + 1]) / 2;
				}
				var q1n = Math.floor(n / 4) + 1;
				var q3n = Math.floor(n * 3 / 4);
				var q1 = values[q1n];
				var q3 = values[q3n];
				var q4 = values[n - 1];
				qArr = [q0, q1, q2, q3, q4];
				data.datasets[x].data[y] = qArr;
			}
		}
		return new Chart(context).Box(data, options);	
	}
	
	this.Bar = function(data, options){
		var repackagedData = calculateMeans(data, options);
		return new Chart(context).Bar(repackagedData, options);
	}
	
	this.Line = function(data, options){
		var repackagedData = calculateMeans(data, options);
		return new Chart(context).Line(repackagedData, options);
	}
	
	this.Scatter = function(data, options){
		var repackagedData = calculateMeans(data, options);
		return new Chart(context).Scatter(repackagedData, options);
	}
	
	function calculateMeans(data, options) {
		for (var x = 0; x < data.datasets.length; x++) {
			var errorValues = [];
			for (var y = 0; y < data.datasets[x].data.length; y++) {
				var values = data.datasets[x].data[y]
				var n = values.length;
				//calculate the average value 
				var sum = 0;
				for (var z = 0; z < n; z++) {
					sum = sum + values[z];
				}
				var avg = sum/n;
				//put the average value into data in place of the array 
				data.datasets[x].data[y] = avg;
				if (options.error){
					if (options.error == "range"){
						//get the maximum value 
						values.sort(function(a, b){return a - b});
						var maximum = values[n - 1];
						var error = maximum - avg;
					} else if (options.error == "stdev" && n > 2) {
						//find the sum of the squares of the diffs from the mean
						var sum = 0;
						for (var z = 0; z < n; z++) {
							sum = sum + Math.pow(values[z] - avg, 2);
						}
						var error = Math.sqrt(sum / (n - 1));
					}
					errorValues.push(error);
				}
			}
			if (options.error) data.datasets[x].error = errorValues;
		}
		return data;
	}
	
}



//Define the global Chart Variable as a class.
window.Chart = function(context) {

	var chart = this;


	//Easing functions adapted from Robert Penner's easing equations
	//http://www.robertpenner.com/easing/

	var animationOptions = {
		linear : function (t){
			return t;
		},
		easeInQuad: function (t) {
			return t*t;
		},
		easeOutQuad: function (t) {
			return -1 *t*(t-2);
		},
		easeInOutQuad: function (t) {
			if ((t/=1/2) < 1) return 1/2*t*t;
			return -1/2 * ((--t)*(t-2) - 1);
		},
		easeInCubic: function (t) {
			return t*t*t;
		},
		easeOutCubic: function (t) {
			return 1*((t=t/1-1)*t*t + 1);
		},
		easeInOutCubic: function (t) {
			if ((t/=1/2) < 1) return 1/2*t*t*t;
			return 1/2*((t-=2)*t*t + 2);
		},
		easeInQuart: function (t) {
			return t*t*t*t;
		},
		easeOutQuart: function (t) {
			return -1 * ((t=t/1-1)*t*t*t - 1);
		},
		easeInOutQuart: function (t) {
			if ((t/=1/2) < 1) return 1/2*t*t*t*t;
			return -1/2 * ((t-=2)*t*t*t - 2);
		},
		easeInQuint: function (t) {
			return 1*(t/=1)*t*t*t*t;
		},
		easeOutQuint: function (t) {
			return 1*((t=t/1-1)*t*t*t*t + 1);
		},
		easeInOutQuint: function (t) {
			if ((t/=1/2) < 1) return 1/2*t*t*t*t*t;
			return 1/2*((t-=2)*t*t*t*t + 2);
		},
		easeInSine: function (t) {
			return -1 * Math.cos(t/1 * (Math.PI/2)) + 1;
		},
		easeOutSine: function (t) {
			return 1 * Math.sin(t/1 * (Math.PI/2));
		},
		easeInOutSine: function (t) {
			return -1/2 * (Math.cos(Math.PI*t/1) - 1);
		},
		easeInExpo: function (t) {
			return (t==0) ? 1 : 1 * Math.pow(2, 10 * (t/1 - 1));
		},
		easeOutExpo: function (t) {
			return (t==1) ? 1 : 1 * (-Math.pow(2, -10 * t/1) + 1);
		},
		easeInOutExpo: function (t) {
			if (t==0) return 0;
			if (t==1) return 1;
			if ((t/=1/2) < 1) return 1/2 * Math.pow(2, 10 * (t - 1));
			return 1/2 * (-Math.pow(2, -10 * --t) + 2);
			},
		easeInCirc: function (t) {
			if (t>=1) return t;
			return -1 * (Math.sqrt(1 - (t/=1)*t) - 1);
		},
		easeOutCirc: function (t) {
			return 1 * Math.sqrt(1 - (t=t/1-1)*t);
		},
		easeInOutCirc: function (t) {
			if ((t/=1/2) < 1) return -1/2 * (Math.sqrt(1 - t*t) - 1);
			return 1/2 * (Math.sqrt(1 - (t-=2)*t) + 1);
		},
		easeInElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
			if (a < Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
		},
		easeOutElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
			if (a < Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			return a*Math.pow(2,-10*t) * Math.sin( (t*1-s)*(2*Math.PI)/p ) + 1;
		},
		easeInOutElastic: function (t) {
			var s=1.70158;var p=0;var a=1;
			if (t==0) return 0;  if ((t/=1/2)==2) return 1;  if (!p) p=1*(.3*1.5);
			if (a < Math.abs(1)) { a=1; var s=p/4; }
			else var s = p/(2*Math.PI) * Math.asin (1/a);
			if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
			return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p )*.5 + 1;
		},
		easeInBack: function (t) {
			var s = 1.70158;
			return 1*(t/=1)*t*((s+1)*t - s);
		},
		easeOutBack: function (t) {
			var s = 1.70158;
			return 1*((t=t/1-1)*t*((s+1)*t + s) + 1);
		},
		easeInOutBack: function (t) {
			var s = 1.70158;
			if ((t/=1/2) < 1) return 1/2*(t*t*(((s*=(1.525))+1)*t - s));
			return 1/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
		},
		easeInBounce: function (t) {
			return 1 - animationOptions.easeOutBounce (1-t);
		},
		easeOutBounce: function (t) {
			if ((t/=1) < (1/2.75)) {
				return 1*(7.5625*t*t);
			} else if (t < (2/2.75)) {
				return 1*(7.5625*(t-=(1.5/2.75))*t + .75);
			} else if (t < (2.5/2.75)) {
				return 1*(7.5625*(t-=(2.25/2.75))*t + .9375);
			} else {
				return 1*(7.5625*(t-=(2.625/2.75))*t + .984375);
			}
		},
		easeInOutBounce: function (t) {
			if (t < 1/2) return animationOptions.easeInBounce (t*2) * .5;
			return animationOptions.easeOutBounce (t*2-1) * .5 + 1*.5;
		}
	};

	//Variables global to the chart
	var width = context.canvas.width;
	var height = context.canvas.height;


	//High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
	if (window.devicePixelRatio) {
		context.canvas.style.width = width + "px";
		context.canvas.style.height = height + "px";
		context.canvas.height = height * window.devicePixelRatio;
		context.canvas.width = width * window.devicePixelRatio;
		context.scale(window.devicePixelRatio, window.devicePixelRatio);
	}
	
	this.PolarArea = function(data,options){

		chart.PolarArea.defaults = {
			scaleOverlay : true,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleShowLine : true,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : "<%=value%>",
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			scaleShowLabelBackdrop : true,
			scaleBackdropColor : "rgba(255,255,255,0.75)",
			scaleBackdropPaddingY : 2,
			scaleBackdropPaddingX : 2,
			segmentShowStroke : true,
			segmentStrokeColor : "#fff",
			segmentStrokeWidth : 2,
			animation : true,
			animationSteps : 100,
			animationEasing : "easeOutBounce",
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};

		var config = (options)? mergeChartConfig(chart.PolarArea.defaults,options) : chart.PolarArea.defaults;

		return new PolarArea(data,config,context);
	};
	
	this.Radar = function(data,options){

		chart.Radar.defaults = {
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleShowLine : true,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			scaleShowLabels : false,
			scaleLabel : "<%=value%>",
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			scaleShowLabelBackdrop : true,
			scaleBackdropColor : "rgba(255,255,255,0.75)",
			scaleBackdropPaddingY : 2,
			scaleBackdropPaddingX : 2,
			angleShowLineOut : true,
			angleLineColor : "rgba(0,0,0,.1)",
			angleLineWidth : 1,
			pointLabelFontFamily : "'Arial'",
			pointLabelFontStyle : "normal",
			pointLabelFontSize : 12,
			pointLabelFontColor : "#666",
			pointDot : true,
			pointDotRadius : 3,
			pointDotStrokeWidth : 1,
			datasetStroke : true,
			datasetStrokeWidth : 2,
			datasetFill : true,
			animation : true,
			animationSteps : 60,
			animationEasing : "easeOutQuart",
			onAnimationComplete : null
		};

		var config = (options)? mergeChartConfig(chart.Radar.defaults,options) : chart.Radar.defaults;

		return new Radar(data,config,context);
	};

	this.Pie = function(data,options){
		chart.Pie.defaults = {
			segmentShowStroke : true,
			segmentStrokeColor : "#fff",
			segmentStrokeWidth : 2,
			animation : true,
			animationSteps : 100,
			animationEasing : "easeOutBounce",
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};

		var config = (options)? mergeChartConfig(chart.Pie.defaults,options) : chart.Pie.defaults;

		return new Pie(data,config,context);
	};

	this.Doughnut = function(data,options){

		chart.Doughnut.defaults = {
			segmentShowStroke : true,
			segmentStrokeColor : "#fff",
			segmentStrokeWidth : 2,
			percentageInnerCutout : 50,
			animation : true,
			animationSteps : 100,
			animationEasing : "easeOutBounce",
			animateRotate : true,
			animateScale : false,
			onAnimationComplete : null
		};

		var config = (options)? mergeChartConfig(chart.Doughnut.defaults,options) : chart.Doughnut.defaults;

		return new Doughnut(data,config,context);

	};
	
	this.Line = function(data,options){

		chart.Line.defaults = {
			chartType: "Line",
			errorStrokeWidth : 1,
			errorStrokeColor : "#333",
			errorCapWidth : 2,
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleShowStartValue : false,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : "<%=value%>",
			scaleLabelPosition : 'left',
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			labelsFontColor : "#666",
			scaleShowGridLines : true,
			scaleGridLineColor : "rgba(0,0,0,.05)",
			scaleGridLineWidth : 1,
			bezierCurve : false,
			pointDot : true,
			pointDotRadius : 4,
			pointDotStrokeWidth : 2,
			datasetStroke : true,
			datasetStrokeWidth : 2,
			datasetFill : false,
			animation : true,
			animationSteps : 60,
			animationEasing : "easeOutQuart",
			onAnimationComplete : null
		};		
		var config = (options) ? mergeChartConfig(chart.Line.defaults,options) : chart.Line.defaults;
		
		return new Line(data,config,context);
	}
	
	this.Scatter = function(data,options){
	
		chart.Line.defaults = {
			//set the chart type
			chartType : "Scatter",
			errorStrokeWidth : 1,
			errorStrokeColor : "#333",
			errorCapWidth : 2,
			
			//y-scale information is still called "scale" to maintain compatibility with the
			//original Chart.js
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			//the next 4 defaults were added by CY
			xScaleOverride: false,
			xScaleSteps: null,
			xScaleStepWidth: null,
			xScaleStartValue: null,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			scaleShowLabels : true,
			scaleLabel : "<%=value%>",
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			scaleShowGridLines : true,
			scaleGridLineColor : "rgba(0,0,0,.05)",
			scaleGridLineWidth : 1,
			//added option for a connecting line, set default to false
			connectingLine : false,
			//changed bezierCurve option default to false
			bezierCurve : false,
			pointDot : true,
			pointDotRadius : 4,
			pointDotStrokeWidth : 2,
			datasetStroke : true,
			datasetStrokeWidth : 2,
			//changed dataset fill default option to false
			datasetFill : false,
			animation : true,
			animationSteps : 60,
			animationEasing : "easeOutQuart",
			onAnimationComplete : null
		};		
		var config = (options) ? mergeChartConfig(chart.Line.defaults,options) : chart.Line.defaults;
		
		var labels = [];
		
		if (config.xScaleOverride){
			//populate this.labels
			var x = config.xScaleStartValue;
			for (i = 0; i < config.xScaleSteps; i++){
				labels.push(x);
				x = x + config.xScaleStepWidth;
			}
		}
		
		data.labels = labels;
		
		return new Line(data, config, context);
	}

	this.Bar = function(data,options){
		chart.Bar.defaults = {
			chartType : "Bar",
			//error bars
			errorStrokeWidth : 5,
			errorStrokeColor : "#333",
			errorCapWidth : 0.75,
			// scale 
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			// scale labels
			scaleShowLabels : true,
			scaleLabel : "<%=value%>",
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			// scale grid lines
			scaleShowGridLines : true,
			scaleGridLineColor : "rgba(0,0,0,.05)",
			scaleGridLineWidth : 1,
			// bar labels
			barShowLabels : false,
			barLabelFormatter : function (s) { return s; },
			barLabelFontFamily : "'Arial'",
			barLabelFontSize : 12,
			barLabelFontStyle : "normal",
			barLabelFontColor : "#666",
			// bar stroke
			barShowStroke : true,
			barStrokeWidth : 2,
			// bar spacing
			barValueSpacing : 5,
			barDatasetSpacing : 1,
			// animation
			animation : true,
			animationSteps : 60,
			animationEasing : "easeOutQuart",
			onAnimationComplete : null
		};
		var config = (options) ? mergeChartConfig(chart.Bar.defaults,options) : chart.Bar.defaults;
		return new Bar(data,config,context);
		
	}
	
	this.Box = function(data,options){
		chart.Bar.defaults = {
			chartType : "Box",
			showWhiskers : true,
			//if false, whiskerWidth is the same as barWidth
			whiskerWidth : false,
			// scale
			scaleOverlay : false,
			scaleOverride : false,
			scaleSteps : null,
			scaleStepWidth : null,
			scaleStartValue : null,
			scaleLineColor : "rgba(0,0,0,.1)",
			scaleLineWidth : 1,
			// scale labels
			scaleShowLabels : true,
			scaleLabel : "<%=value%>",
			scaleFontFamily : "'Arial'",
			scaleFontSize : 12,
			scaleFontStyle : "normal",
			scaleFontColor : "#666",
			// scale grid lines
			scaleShowGridLines : true,
			scaleGridLineColor : "rgba(0,0,0,.05)",
			scaleGridLineWidth : 1,
			// bar labels
			barShowLabels : false,
			barLabelFormatter : function (s) { return s; },
			barLabelFontFamily : "'Arial'",
			barLabelFontSize : 12,
			barLabelFontStyle : "normal",
			barLabelFontColor : "#666",
			// bar stroke
			barShowStroke : true,
			barStrokeWidth : 5,
			// bar spacing
			barValueSpacing : 5,
			barDatasetSpacing : 0,
			// animation
			animation : true,
			animationSteps : 60,
			animationEasing : "easeOutQuart",
			onAnimationComplete : null,
			// outliers
			outlierShowLabels : true,
			outlierLabelFormatter : function(s){return s;},
			outlierLabelFontFamily : "'Arial'",
			outlierLabelFontStyle : "normal",
			outlierLabelFontSize : 12,        // pixels
			outlierLabelFontColor : "#666",
			outlierLabelPlacement : "right",  // left, top, bottom
			outlierLabelMargin : 2,           // pixels. between label and dot
			outlierDotStyle : 'disc',         // options: disc, circle
			outlierDotFillColor : "#666",
			outlierDotRadius : 2,             // pixels
			outlierDotStrokeWidth : 2,        // pixels
			outlierDotStrokeColor : "#666",
		};
		var config = (options) ? mergeChartConfig(chart.Bar.defaults,options) : chart.Bar.defaults;
		
		return new Bar(data,config,context);
	}

	var clear = function(c){
		c.clearRect(0, 0, width, height);
	};

	var PolarArea = function(data,config,ctx){
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;

		calculateDrawingSizes();

		valueBounds = getValueBounds();

		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;

		//Check and set the scale
		if (!config.scaleOverride){

			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}

		scaleHop = maxSize/(calculatedScale.steps);

		//Wrap in an animation loop wrapper
		animationLoop(config,drawScale,drawAllSegments,ctx);

		function calculateDrawingSizes(){
			maxSize = (Min([width,height])/2);
			//Remove whatever is larger - the font size or line width.

			maxSize -= Max([config.scaleFontSize*0.5,config.scaleLineWidth*0.5]);

			labelHeight = config.scaleFontSize*2;
			//If we're drawing the backdrop - add the Y padding to the label height and remove from drawing region.
			if (config.scaleShowLabelBackdrop){
				labelHeight += (2 * config.scaleBackdropPaddingY);
				maxSize -= config.scaleBackdropPaddingY*1.5;
			}

			scaleHeight = maxSize;
			//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
			labelHeight = Default(labelHeight,5);
		}
		function drawScale(){
			for (var i=0; i<calculatedScale.steps; i++){
				//If the line object is there
				if (config.scaleShowLine){
					ctx.beginPath();
					ctx.arc(width/2, height/2, scaleHop * (i + 1), 0, (Math.PI * 2), true);
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = config.scaleLineWidth;
					ctx.stroke();
				}

				if (config.scaleShowLabels){
					ctx.textAlign = "center";
					ctx.font = config.scaleFontStyle + " " + config.scaleFontSize + "px " + config.scaleFontFamily;
					var label =  calculatedScale.labels[i];
					//If the backdrop object is within the font object
					if (config.scaleShowLabelBackdrop){
						var textWidth = ctx.measureText(label).width;
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(width/2 - textWidth/2 - config.scaleBackdropPaddingX), //X
							Math.round(height/2 - (scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
							Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
							Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
						);
						ctx.fill();
					}
					ctx.textBaseline = "middle";
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillText(label,width/2,height/2 - (scaleHop * (i + 1)));
				}
			}
		}
		function drawAllSegments(animationDecimal){
			var startAngle = -Math.PI/2,
			angleStep = (Math.PI*2)/data.length,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}

			for (var i=0; i<data.length; i++){

				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * calculateOffset(data[i].value,calculatedScale,scaleHop),startAngle, startAngle + rotateAnimation*angleStep, false);
				ctx.lineTo(width/2,height/2);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();

				if(config.segmentShowStroke){
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.stroke();
				}
				startAngle += rotateAnimation*angleStep;
			}
		}
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i<data.length; i++){
				if (data[i].value > upperValue) {upperValue = data[i].value;}
				if (data[i].value < lowerValue) {lowerValue = data[i].value;}
			};

			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));

			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};


		}
	}

	var Radar = function (data,config,ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;

		//If no labels are defined set to an empty array, so referencing length for looping doesn't blow up.
		if (!data.labels) data.labels = [];

		calculateDrawingSizes();

		var valueBounds = getValueBounds();

		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;

		//Check and set the scale
		if (!config.scaleOverride){

			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}

		scaleHop = maxSize/(calculatedScale.steps);

		animationLoop(config,drawScale,drawAllDataPoints,ctx);

		//Radar specific functions.
		function drawAllDataPoints(animationDecimal){
			var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;

			ctx.save();
			//translate to the centre of the canvas.
			ctx.translate(width/2,height/2);

			// strokeWidth never changes during the loop so we cache it beforehand
			var strokeWidth = config.datasetStroke && config.datasetStrokeWidth;

			//We accept multiple data sets for radar charts, so show loop through each set
			for (var i=0; i<data.datasets.length; i++){
				ctx.beginPath();

				ctx.moveTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)));
				for (var j=1; j<data.datasets[i].data.length; j++){
					ctx.rotate(rotationDegree);
					ctx.lineTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)));

				}
				ctx.closePath();
				ctx.fillStyle = data.datasets[i].fillColor;
				ctx.strokeStyle = data.datasets[i].strokeColor;
				ctx.lineWidth = strokeWidth;
				ctx.fill();
				ctx.stroke();
				if (config.pointDot){
					ctx.fillStyle = data.datasets[i].pointColor;
					ctx.strokeStyle = data.datasets[i].pointStrokeColor;
					ctx.lineWidth = config.pointDotStrokeWidth;
					for (var k=0; k<data.datasets[i].data.length; k++){
						ctx.rotate(rotationDegree);
						ctx.beginPath();
						ctx.arc(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,2*Math.PI,false);
						ctx.fill();
						ctx.stroke();
					}

				}
				ctx.rotate(rotationDegree);

			}
			ctx.restore();


		}
		function drawScale(){
			var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;
			ctx.save();
		    ctx.translate(width / 2, height / 2);
			if (config.angleShowLineOut){
				ctx.strokeStyle = config.angleLineColor;
				ctx.lineWidth = config.angleLineWidth;
				for (var h=0; h<data.datasets[0].data.length; h++){		
					ctx.rotate(rotationDegree);
					ctx.beginPath();
					ctx.moveTo(0,0);
					ctx.lineTo(0,-maxSize);
					ctx.stroke();
				}
			}

			for (var i=0; i<calculatedScale.steps; i++){
				ctx.beginPath();

				if(config.scaleShowLine){
					ctx.strokeStyle = config.scaleLineColor;
					ctx.lineWidth = config.scaleLineWidth;
					ctx.moveTo(0,-scaleHop * (i+1));
					for (var j=0; j<data.datasets[0].data.length; j++){
						ctx.rotate(rotationDegree);
						ctx.lineTo(0,-scaleHop * (i+1));
					}
					ctx.closePath();
					ctx.stroke();			
				}
				if (config.scaleShowLabels){
					ctx.textAlign = 'center';
					ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
					ctx.textBaseline = "middle";

					if (config.scaleShowLabelBackdrop){
						var textWidth = ctx.measureText(calculatedScale.labels[i]).width;
						ctx.fillStyle = config.scaleBackdropColor;
						ctx.beginPath();
						ctx.rect(
							Math.round(- textWidth/2 - config.scaleBackdropPaddingX),     //X
							Math.round((-scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
							Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
							Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
						);
						ctx.fill();
					}
					ctx.fillStyle = config.scaleFontColor;
					ctx.fillText(calculatedScale.labels[i],0,-scaleHop*(i+1));
				}

			}
			for (var k=0; k<data.labels.length; k++){
			ctx.font = config.pointLabelFontStyle + " " + config.pointLabelFontSize+"px " + config.pointLabelFontFamily;
			ctx.fillStyle = config.pointLabelFontColor;
				var opposite = Math.sin(rotationDegree*k) * (maxSize + config.pointLabelFontSize);
				var adjacent = Math.cos(rotationDegree*k) * (maxSize + config.pointLabelFontSize);

				if(rotationDegree*k == Math.PI || rotationDegree*k == 0){
					ctx.textAlign = "center";
				}
				else if(rotationDegree*k > Math.PI){
					ctx.textAlign = "right";
				}
				else{
					ctx.textAlign = "left";
				}

				ctx.textBaseline = "middle";

				ctx.fillText(data.labels[k],opposite,-adjacent);

			}
			ctx.restore();
		};
		function calculateDrawingSizes(){
			maxSize = (Min([width,height])/2);

			labelHeight = config.scaleFontSize*2;

			var labelLength = 0;
			for (var i=0; i<data.labels.length; i++){
				ctx.font = config.pointLabelFontStyle + " " + config.pointLabelFontSize+"px " + config.pointLabelFontFamily;
				var textMeasurement = ctx.measureText(data.labels[i]).width;
				if(textMeasurement>labelLength) labelLength = textMeasurement;
			}

			//Figure out whats the largest - the height of the text or the width of what's there, and minus it from the maximum usable size.
			maxSize -= Max([labelLength,((config.pointLabelFontSize/2)*1.5)]);
			maxSize -= config.pointLabelFontSize;
			maxSize = CapValue(maxSize, null, 0);
			scaleHeight = maxSize;
			//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
			labelHeight = Default(labelHeight,5);
		};
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;

			for (var i=0; i<data.datasets.length; i++){
				for (var j=0; j<data.datasets[i].data.length; j++){
					if (data.datasets[i].data[j] > upperValue){upperValue = data.datasets[i].data[j]}
					if (data.datasets[i].data[j] < lowerValue){lowerValue = data.datasets[i].data[j]}
				}
			}

			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));

			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};


		}
	}

	var Pie = function(data,config,ctx){
		var segmentTotal = 0;

		//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
		var pieRadius = Min([height/2,width/2]) - 5;

		for (var i=0; i<data.length; i++){
			segmentTotal += data[i].value;
		}


		animationLoop(config,null,drawPieSegments,ctx);

		function drawPieSegments (animationDecimal){
			var cumulativeAngle = -Math.PI/2,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}
			for (var i=0; i<data.length; i++){
				var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * pieRadius,cumulativeAngle,cumulativeAngle + segmentAngle);
				ctx.lineTo(width/2,height/2);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();

				if(config.segmentShowStroke){
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.stroke();
				}
				cumulativeAngle += segmentAngle;
			}
		}
	}

	var Doughnut = function(data,config,ctx){
		var segmentTotal = 0;

		//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
		var doughnutRadius = Min([height/2,width/2]) - 5;

		var cutoutRadius = doughnutRadius * (config.percentageInnerCutout/100);

		for (var i=0; i<data.length; i++){
			segmentTotal += data[i].value;
		}


		animationLoop(config,null,drawPieSegments,ctx);


		function drawPieSegments (animationDecimal){
			var cumulativeAngle = -Math.PI/2,
			scaleAnimation = 1,
			rotateAnimation = 1;
			if (config.animation) {
				if (config.animateScale) {
					scaleAnimation = animationDecimal;
				}
				if (config.animateRotate){
					rotateAnimation = animationDecimal;
				}
			}
			for (var i=0; i<data.length; i++){
				var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
				ctx.beginPath();
				ctx.arc(width/2,height/2,scaleAnimation * doughnutRadius,cumulativeAngle,cumulativeAngle + segmentAngle,false);
				ctx.arc(width/2,height/2,scaleAnimation * cutoutRadius,cumulativeAngle + segmentAngle,cumulativeAngle,true);
				ctx.closePath();
				ctx.fillStyle = data[i].color;
				ctx.fill();

				if(config.segmentShowStroke){
					ctx.lineWidth = config.segmentStrokeWidth;
					ctx.strokeStyle = config.segmentStrokeColor;
					ctx.stroke();
				}
				cumulativeAngle += segmentAngle;
			}
		}
	}
	
	var Line = function(data,config,ctx) {
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength, xAspectRatio, yAxisPosX,xAxisPosY, rotateLabels = 0;
		
		calculateDrawingSizes();

		valueBounds = getValueBounds();
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : "";
		if (!config.scaleOverride){

			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		} else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth, config.scaleShowStartValue);
		}

		scaleHop = Math.floor(scaleHeight/calculatedScale.steps);
		calculateXAxisSize();

		if (config.chartType == "Line"){
			animationLoop(config,drawScale,drawLines,ctx);
		} else {
			animationLoop(config,drawScale,drawPoints,ctx);
		}

		function drawLines(animPc){
			var strokeWidth = config.datasetStroke && config.datasetStrokeWidth;
			for (var i=0; i<data.datasets.length; i++){
				
				ctx.strokeStyle = data.datasets[i].strokeColor;
				ctx.lineWidth = strokeWidth;
				ctx.beginPath();
				ctx.moveTo(yAxisPosX, xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)))

				for (var j=1; j<data.datasets[i].data.length; j++){
					if (config.bezierCurve){
                        ctx.bezierCurveTo(getXPos(j-0.5),getYPos(i,j-1),getXPos(j-0.5),getYPos(i,j),getXPos(j),getYPos(i,j));
					}
					else{
                        ctx.lineTo(getXPos(j),getYPos(i,j));
					}
				}
				ctx.stroke();
				if (config.datasetFill){
					ctx.lineTo(yAxisPosX + (valueHop*(data.datasets[i].data.length-1)),xAxisPosY);
					ctx.lineTo(yAxisPosX,xAxisPosY);
					ctx.closePath();
					ctx.fillStyle = data.datasets[i].fillColor;
					ctx.fill();
				}
				else{
					ctx.closePath();
				}
				if(config.pointDot){
					for (var k=0; k<data.datasets[i].data.length; k++){
						ctx.fillStyle = data.datasets[i].pointColor;
						ctx.strokeStyle = data.datasets[i].pointStrokeColor;
						ctx.lineWidth = config.pointDotStrokeWidth;
						ctx.beginPath();
						var xPos = yAxisPosX + (valueHop *k);
						var yPos = xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop));
						ctx.arc( xPos, yPos, config.pointDotRadius, 0 ,Math.PI*2, true );
						ctx.fill();
						ctx.stroke();
						//the if block below was added by CY to draw error bars in line charts
						if (data.datasets[i].error){
							ctx.lineWidth = config.errorStrokeWidth;
							ctx.strokeStyle = config.errorStrokeColor;
							ctx.beginPath();
							ctx.moveTo(xPos,yPos);
							var yTopError = xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k] + data.datasets[i].error[k],calculatedScale,scaleHop));
							var yBottomError = xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k] - data.datasets[i].error[k],calculatedScale,scaleHop));
							ctx.lineTo(xPos, yTopError)
							ctx.stroke();
							ctx.beginPath();
							var cap = (config.errorCapWidth * config.pointDotRadius);
							ctx.moveTo(xPos - cap/2, yTopError);
							ctx.lineTo(xPos + cap/2, yTopError);
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(xPos, yPos);
							ctx.lineTo(xPos, yBottomError);
							ctx.stroke();
							ctx.beginPath();
							ctx.moveTo(xPos - cap/2, yBottomError);
							ctx.lineTo(xPos + cap/2, yBottomError);
							ctx.stroke();
						}
					}
				}
			}

			function getYPos(dataSet,iteration){
				return xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));
			}			

			function yPos(dataSet,iteration){
				return xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));
			}
			
            function getXPos(iteration){
				return yAxisPosX + (valueHop * iteration);
			}
		}
		
		//this function was added to draw scatter plots. The xPosition and 
		//yPosition functions were modified slighly to support this.
		function drawPoints(animPc) {
			for (var i=0; i<data.datasets.length; i++){
				//xAspectRatio = , yAxisPosX, config.xScaleStartValue
				for (var k=0; k<data.datasets[i].data.length; k++){
					var xPos = xPosition(i, k);
					var yPos = yPosition(i, k);
					if(config.pointDot){
						ctx.fillStyle = data.datasets[i].pointColor;
						ctx.strokeStyle = data.datasets[i].pointStrokeColor;
						ctx.lineWidth = config.pointDotStrokeWidth;
						ctx.beginPath();
						ctx.arc(xPos, yPos,config.pointDotRadius,0,Math.PI*2,true);
						ctx.fill();
						ctx.stroke();
					}
					//draw the error bars
					if (data.datasets[i].error){
						ctx.lineWidth = config.errorStrokeWidth;
						ctx.strokeStyle = config.errorStrokeColor;
						ctx.beginPath();
						ctx.moveTo(xPos, yPos);
						var yTopError = xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k] + data.datasets[i].error[k],calculatedScale,scaleHop));
						var yBottomError = xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k] - data.datasets[i].error[k],calculatedScale,scaleHop));
						ctx.lineTo(xPos, yTopError)
						ctx.stroke();
						ctx.beginPath();
						var cap = (config.errorCapWidth * config.pointDotRadius);
						ctx.moveTo(xPos - cap/2, yTopError);
						ctx.lineTo(xPos + cap/2, yTopError);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(xPos, yPos);
						ctx.lineTo(xPos, yBottomError);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(xPos - cap/2, yBottomError);
						ctx.lineTo(xPos + cap/2, yBottomError);
						ctx.stroke();
					}
					if (config.connectingLine) {
						ctx.strokeStyle = data.datasets[i].strokeColor;
						ctx.lineWidth = config.datasetStrokeWidth;
						ctx.beginPath();
						ctx.moveTo(xPos, yPos);
						var newXPos = xPosition(i, k + 1);
						var newYPos = yPosition(i, k + 1);
						if (!config.bezierCurve && k + 1 < data.datasets[i].data.length) {
							ctx.lineTo(newXPos, newYPos);
							ctx.stroke();
						} else if (k + 1 < data.datasets[i].data.length) {
							var halfX = (xPos + newXPos) / 2;
							ctx.bezierCurveTo(halfX, yPos, halfX, newYPos, newXPos, newYPos);
							ctx.stroke();
						}
					}	
				}
				if (data.datasets[i].trendline) {
					//determine the equation of the trendline from a least-squares method
					var sumX = 0;
					var sumY = 0;
					var sumXY = 0;
					var sumXX = 0; 
					var sumYY = 0;
					for (var z = 0; z < data.datasets[i].data.length; z++) {
						var X = data.datasets[i].xVal[z];
						var Y = data.datasets[i].data[z];
						sumX = sumX + X;
						sumY = sumY + Y;
						sumXY = sumXY + X * Y;
						sumXX = sumXX + X * X;
						sumYY = sumYY + Y * Y;
					}
					var m = (z * sumXY - sumX * sumY) / (z * sumXX - sumX * sumX);
					var b = (sumY - m * sumX) / z;
					/*R-sqaured value. Not currently used for anything but might be valuable
					if equation display function is added in future.
					var r2 = Math.pow((z * sumXY - sumX * sumY)/Math.sqrt((z * sumXX - sumX * sumX) * (z * sumYY - sumY * sumY)), 2)*/
					
					//determine the starting and ending x points;
					if (typeof data.datasets[i].trendlineStart == 'undefined') {
						var startX = data.datasets[i].xVal[0];
					} else {
						var startX = data.datasets[i].trendlineStart;
					}
					if (typeof data.datasets[i].trendlineEnd == 'undefined') {
						var endX = data.datasets[i].xVal[data.datasets[i].xVal.length - 1];
					} else {
						var endX = data.datasets[i].trendlineEnd;
					}
					var startY = m * startX + b;
					var endY = m * endX + b;
					
					//draw the trendline
					ctx.strokeStyle = data.datasets[i].strokeColor;
					ctx.lineWidth = config.datasetStrokeWidth;
					ctx.beginPath();
					ctx.moveTo(yAxisPosX + startX / xAspectRatio, xAxisPosY - animPc*(calculateOffset(startY,calculatedScale,scaleHop)));
					ctx.lineTo(yAxisPosX + endX / xAspectRatio, xAxisPosY - animPc*(calculateOffset(endY,calculatedScale,scaleHop)));
					ctx.stroke();
				}
			}
			
			function yPosition(dataSet,iteration){
				return xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));
			}
			//modified by CY. The key is xAspectRatio, which is the ratio between 
			//the data spread represented by the x-axis and the actual size of the 
			//x-axis in pixels.
			function xPosition(dataSet, iteration){
				return yAxisPosX + data.datasets[dataSet].xVal[iteration] / xAspectRatio;
			}
		}
		
		function drawScale(){
			//X axis line
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
			ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
			ctx.stroke();


			if (rotateLabels > 0){
				ctx.save();
				ctx.textAlign = "right";
			}
			else{
				ctx.textAlign = "center";
			}
			ctx.fillStyle = config.labelsFontColor;
			for (var i=0; i<data.labels.length; i++){
				ctx.save();
				if (rotateLabels > 0){
					ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
					ctx.rotate(-(rotateLabels * (Math.PI/180)));
					ctx.fillText(data.labels[i], 0,0);
					ctx.restore();
				}

				else{
					ctx.fillText(data.labels[i], yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize+3);
				}

				ctx.beginPath();
				ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY+3);

				//Check i isnt 0, so we dont go over the Y axis twice.
				if((config.scaleShowGridLines == 'vertical' || config.scaleShowGridLines === true) && i > 0){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + i * valueHop, 5);
				}
				else{
					ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY+3);
				}
				ctx.stroke();
			}

			//Y axis
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.fillStyle = config.scaleFontColor;
			ctx.beginPath();
			ctx.moveTo(yAxisPosX,xAxisPosY+5);
			ctx.lineTo(yAxisPosX,5);
			ctx.stroke();

			ctx.textAlign = config.scaleLabelPosition == "right" ? 'left' : 'right';
			ctx.textBaseline = "middle";

			var k = calculatedScale.steps;
			if (config.scaleShowStartValue) {
				++k;
			}
			for (var j = +!config.scaleShowStartValue; j < k; j++){
				ctx.beginPath();
				ctx.moveTo(yAxisPosX - 3, xAxisPosY - (j * scaleHop));
				if (config.scaleShowGridLines == 'horizontal' || config.scaleShowGridLines === true){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));
				}
				else{
					ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
				}

				ctx.stroke();

				if (config.scaleShowLabels) {
					ctx.fillText(
						calculatedScale.labels[j],
						yAxisPosX - 8 + (config.scaleLabelPosition == 'right' ? xAxisLength + 20 : 0),
						xAxisPosY - (j * scaleHop)
					);
				}
			}


		}
		function calculateXAxisSize(){
			var longestText = 1;
			//if we are showing the labels
			if (config.scaleShowLabels){
				ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
				for (var i=0; i<calculatedScale.labels.length; i++){
					var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
					longestText = (measuredText > longestText)? measuredText : longestText;
				}
				//Add a little extra padding from the y axis
				longestText +=10;
			}
			widestYLabel = longestText;
			xAxisLength = width - longestText - widestXLabel;
			//took out Math.floor - no reason valueHop can't be a decimal
			valueHop = xAxisLength/(data.labels.length-1);
			//added by CY
			var xValueSpread = (config.xScaleSteps - 1) * config.xScaleStepWidth;
			xAspectRatio = xValueSpread / xAxisLength;
			yAxisPosX = width-widestXLabel/2-xAxisLength;
			xAxisPosY = scaleHeight + config.scaleFontSize/2;
		}		

		function calculateDrawingSizes(){
			maxSize = height;

			//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
			ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
			widestXLabel = 1;
			for (var i=0; i<data.labels.length; i++){
				var textLength = ctx.measureText(data.labels[i]).width;
				//If the text length is longer - make that equal to longest text!
				widestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;
			}
			if (width/data.labels.length < widestXLabel){
				rotateLabels = 45;
				if (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){
					rotateLabels = 90;
					maxSize -= widestXLabel;
				}
				else{
					maxSize -= Math.sin(rotateLabels) * widestXLabel;
				}
			}
			else{
				maxSize -= config.scaleFontSize;
			}

			//Add a little padding between the x line and the text
			maxSize -= 5;


			labelHeight = config.scaleFontSize;

			maxSize -= labelHeight;
			//Set 5 pixels greater than the font size to allow for a little padding from the X axis.

			scaleHeight = maxSize;

			//Then get the area above we can safely draw on.

		}
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i<data.datasets.length; i++){
				for (var j=0; j<data.datasets[i].data.length; j++){
					if ( data.datasets[i].data[j] > upperValue) { upperValue = data.datasets[i].data[j] };
					if ( data.datasets[i].data[j] < lowerValue) { lowerValue = data.datasets[i].data[j] };
				}
			};

			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));

			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};


		}


	}

	var Bar = function(data,config,ctx){
		var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY,barWidth, rotateLabels = 0;

		calculateDrawingSizes();

		valueBounds = getValueBounds();
		//Check and set the scale
		labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : "";
		if (!config.scaleOverride){

			calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
		}
		else {
			calculatedScale = {
				steps : config.scaleSteps,
				stepValue : config.scaleStepWidth,
				graphMin : config.scaleStartValue,
				labels : []
			}
			populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
		}

		scaleHop = Math.floor(scaleHeight/calculatedScale.steps);
		calculateXAxisSize();

		if (config.chartType == "Box") {
			animationLoop(config,drawScale,drawBoxes,ctx);
		} else {
			animationLoop(config,drawScale,drawBars,ctx);
		}
    
		// This function returns the fill color found in an object of variable type
		// If functionOrObject is a string, returns the string's value
		// If functionOrObject is an array, uses nth element of array and recurses
		//   (where n is index modulo length)
		// If functionOrObject is a function, runs the function and returns its
		//   return value. This enables bars to change color as the animation
		//   continues.
		var getFillColor = (function(functionOrObject, index, dataValue, animationPercent) {
			if (typeof functionOrObject == "string") {
				return functionOrObject;
			} else if (typeof functionOrObject == "function") {
				return functionOrObject(dataValue, animationPercent);
			} else if (Object.prototype.toString.call( functionOrObject ) === '[object Array]') {
				// cycle through it
				// recurse in case each element is a function, or subarray?
				return getFillColor(functionOrObject[index%functionOrObject.length], index, dataValue, animationPercent);
			} else {
				if (this.console) {
					console.log("could not read fill color function, returning #000000");
				}
				return "#000000";
			}
		});
		
		//arg animPc is the fraction-complete of the animation - ie
		//it has a value of 1 for the final chart

		function drawBars(animPc){
			ctx.lineWidth = config.barStrokeWidth;
			//i is looping through the datasets ...
			for (var i=0; i<data.datasets.length; i++){
					ctx.strokeStyle = data.datasets[i].strokeColor;
				//... wheras j is looping through the individual data points
				for (var j=0; j<data.datasets[i].data.length; j++){
					ctx.save();
					
					ctx.fillStyle = getFillColor(data.datasets[i].fillColor, j, data.datasets[i].data[j], animPc);
					
					var barOffset = yAxisPosX + config.barValueSpacing + valueHop*j + barWidth*i + config.barDatasetSpacing*i + config.barStrokeWidth*i;
					var barTop = xAxisPosY - animPc * calculateOffset(data.datasets[i].data[j], calculatedScale, scaleHop) + (config.barStrokeWidth / 2);
					ctx.beginPath();
					//bottom left corner
					ctx.moveTo(barOffset, xAxisPosY);
					//top left corner
					ctx.lineTo(barOffset, barTop);
					//top right corner
					ctx.lineTo(barOffset + barWidth, barTop);
					//bottom right corner
					ctx.lineTo(barOffset + barWidth, xAxisPosY);
					if(config.barShowStroke){
						ctx.stroke();
					}
					ctx.closePath();
					ctx.fill();
					ctx.restore();
					if (config.barShowLabels) {
						ctx.save();
						ctx.textAlign = "center";
						ctx.font = config.barLabelFontStyle + " " + config.barLabelFontSize + "px " + config.barLabelFontFamily;
						var label = config.barLabelFormatter(data.datasets[i].data[j]);
						ctx.textBaseline = "bottom";
						ctx.fillStyle = config.barLabelFontColor;
						ctx.fillText(label, barOffset + barWidth / 2, barTop - 4);
						ctx.restore();
					}
					
					//check the previous pull request for any other changes?
					//update documentation
					if ( data.datasets[i].error && config.errorDir != "none"){
						//draw upper error bar
						if ( config.errorDir != "down") {		
							ctx.strokeStyle = config.errorStrokeWidth;
							ctx.beginPath();
							ctx.moveTo(barOffset + barWidth/2, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.lineTo(barOffset + barWidth/2, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] + data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2))
							ctx.stroke();
							ctx.beginPath();
							var cap = (config.errorCapWidth * barWidth) || 1;
							capOffset = (barWidth - cap)/2;
							ctx.moveTo(barOffset + capOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] + data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.lineTo(barOffset + barWidth - capOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] + data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.stroke();
						}
						
						//draw lower error bar
						if (config.errorDir != "up") {						
							ctx.beginPath();
							ctx.moveTo(barOffset + barWidth/2, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.lineTo(barOffset + barWidth/2, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] - data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2))
							ctx.stroke();
							ctx.beginPath();
							var cap = (config.errorCapWidth * barWidth) || 1;
							capOffset = (barWidth - cap)/2;
							ctx.moveTo(barOffset + capOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] - data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.lineTo(barOffset + barWidth - capOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j] - data.datasets[i].error[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
							ctx.stroke();					
						}
					}
				}
			}
		}
		
		function drawBoxes(animPc) {
			ctx.lineWidth = config.barStrokeWidth;
			//i is looping through the datasets ...
			for (var i=0; i<data.datasets.length; i++){
				ctx.strokeStyle = data.datasets[i].strokeColor;
				//... wheras j is looping through the individual data points
				for (var j=0; j<data.datasets[i].data.length; j++){
					ctx.fillStyle = getFillColor(data.datasets[i].fillColor, j, data.datasets[i].data[j], animPc);
					
					var barOffset = yAxisPosX + config.barValueSpacing + valueHop*j + barWidth*i + config.barDatasetSpacing*i + config.barStrokeWidth*i;
					ctx.beginPath();
					
					// reusable values of grid features
					var wis = (config.whiskerWidth * barWidth) || 1;
					wisOffset = (barWidth - wis)/2;
					var leftX   = barOffset;
					var centerX = barOffset + barWidth/2;
					var rightX  = barOffset + barWidth;
					var whiskerMinX = barOffset + wisOffset;
					var whiskerMaxX = barOffset + barWidth - wisOffset;
					var getYForIndex = (function(index){ return xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j][index],calculatedScale,scaleHop)+(config.barStrokeWidth/2); });
					var minY    = getYForIndex(0);
					var bottomY = getYForIndex(1);
					var medianY = getYForIndex(2);
					var topY    = getYForIndex(3);
					var maxY    = getYForIndex(4);
					
					// box
					ctx.moveTo(leftX, bottomY);
					ctx.lineTo(leftX, topY);
					ctx.lineTo(rightX, topY);
					ctx.lineTo(rightX, bottomY);
					ctx.closePath();
					ctx.stroke();
					if(config.datasetFill){
						ctx.fill();
					}
					//draw the median line
					ctx.beginPath();
					ctx.moveTo(leftX, medianY);
					ctx.lineTo(rightX, medianY);
					ctx.stroke();
					
					if (config.showWhiskers) {
						//draw the lower whisker
						ctx.beginPath();
						ctx.moveTo(centerX, minY);
						ctx.lineTo(centerX, bottomY);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(whiskerMinX, minY);
						ctx.lineTo(whiskerMaxX, minY);
						ctx.stroke();
						//draw the upper whisker
						ctx.beginPath();
						ctx.moveTo(centerX, topY);
						ctx.lineTo(centerX, maxY);
						ctx.stroke();
						ctx.beginPath();
						ctx.moveTo(whiskerMinX, maxY);
						ctx.lineTo(whiskerMaxX, maxY);
						ctx.stroke();
					}
					
					if (config.barShowLabels) {
						ctx.save(); // we're going to be messing with font settings
						
						ctx.textAlign = "center";
						ctx.font = config.barLabelFontStyle + " " + config.barLabelFontSize + "px " + config.barLabelFontFamily;
						ctx.fillStyle = config.barLabelFontColor;
						
						var bottomLabelY = (config.showWhiskers ? minY : bottomY) + 2;
						var topLabelY = (config.showWhiskers ? maxY : topY) - 2;
						
						ctx.textBaseline = "top";
						var label = config.barLabelFormatter(data.datasets[i].data[j][(config.showWhiskers ? 0 : 1)]);
						ctx.fillText(label, barOffset + barWidth / 2, bottomLabelY);
						
						ctx.textBaseline = "bottom";
						label = config.barLabelFormatter(data.datasets[i].data[j][(config.showWhiskers ? 4 : 3)]);
						ctx.fillText(label, barOffset + barWidth / 2, topLabelY);
						
						ctx.restore();
					}
					
					// draw outlier dots & labels
					if (data.datasets[i].outliers !== undefined &&
							data.datasets[i].outliers[j] !== undefined) {
						ctx.save();
						ctx.strokeStyle = config.outlierDotStrokeColor;
						
						for (var k=0; k<data.datasets[i].outliers[j].length; k++) {
							var outlier = data.datasets[i].outliers[j][k];
							var outlierDotX = centerX;
							var outlierDotY = xAxisPosY - animPc*calculateOffset(outlier,calculatedScale,scaleHop)+(config.barStrokeWidth/2);
							ctx.beginPath();
							ctx.arc(outlierDotX, outlierDotY, config.outlierDotRadius, 0, Math.PI*2);
							ctx.stroke();
							if (config.outlierDotStyle == "disc") {
								ctx.fillStyle = config.outlierDotFillColor;
								ctx.fill();
							}
							
							if (config.outlierShowLabels) {
								var outlierLabelX, outlierLabelY;
								var outlierLabelDotGap = config.outlierDotRadius + config.outlierDotStrokeWidth + config.outlierLabelMargin;
								switch(config.outlierLabelPlacement) {
									case "right":
										ctx.textAlign = "left";
										ctx.textBaseline = "center";
										outlierLabelX = outlierDotX + outlierLabelDotGap;
										outlierLabelY = outlierDotY;
										break;
									case "left":
										ctx.textAlign = "right";
										ctx.textBaseline = "center";
										outlierLabelX = outlierDotX - outlierLabelDotGap;
										outlierLabelY = outlierDotY;
										break;
									case "top":
										ctx.textAlign = "center";
										ctx.textBaseline = "bottom";
										outlierLabelX = outlierDotX;
										outlierLabelY = outlierDotY - outlierLabelDotGap;
										break;
									case "bottom":
										ctx.textAlign = "center";
										ctx.textBaseline = "top";
										outlierLabelX = outlierDotX;
										outlierLabelY = outlierDotY + outlierLabelDotGap;
										break;
								}
								ctx.font = config.outlierLabelFontStyle + " " + config.outlierLabelFontSize + "px" + config.outlierLabelFontFamily;
								ctx.fillStyle = config.outlierLabelFontColor;
								var label = config.outlierLabelFormatter(outlier);
								ctx.fillText(label, outlierLabelX, outlierLabelY);
							}
						}
						ctx.restore();
					}
				}
			}
		}
		
		function drawScale(){
			//X axis line
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
			ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
			ctx.stroke();


			if (rotateLabels > 0){
				ctx.save();
				ctx.textAlign = "right";
			}
			else{
				ctx.textAlign = "center";
			}
			ctx.fillStyle = config.scaleFontColor;
			for (var i=0; i<data.labels.length; i++){
				ctx.save();
				if (rotateLabels > 0){
					ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
					ctx.rotate(-(rotateLabels * (Math.PI/180)));
					ctx.fillText(data.labels[i], 0,0);
					ctx.restore();
				}

				else{
					ctx.fillText(data.labels[i], yAxisPosX + i*valueHop + valueHop/2,xAxisPosY + config.scaleFontSize+3);
				}

				ctx.beginPath();
				ctx.moveTo(yAxisPosX + (i+1) * valueHop, xAxisPosY+3);

				//Check i isnt 0, so we dont go over the Y axis twice.
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + (i+1) * valueHop, 5);
				ctx.stroke();
			}

			//Y axis
			ctx.lineWidth = config.scaleLineWidth;
			ctx.strokeStyle = config.scaleLineColor;
			ctx.beginPath();
			ctx.moveTo(yAxisPosX,xAxisPosY+5);
			ctx.lineTo(yAxisPosX,5);
			ctx.stroke();

			ctx.textAlign = "right";
			ctx.textBaseline = "middle";
			for (var j=0; j<calculatedScale.steps; j++){
				ctx.beginPath();
				ctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));
				if (config.scaleShowGridLines){
					ctx.lineWidth = config.scaleGridLineWidth;
					ctx.strokeStyle = config.scaleGridLineColor;
					ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));
				}
				else{
					ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
				}

				ctx.stroke();
				if (config.scaleShowLabels){
					ctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));
				}
			}


		}
		function calculateXAxisSize(){
			var longestText = 1;
			//if we are showing the labels
			if (config.scaleShowLabels){
				ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
				for (var i=0; i<calculatedScale.labels.length; i++){
					var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
					longestText = (measuredText > longestText)? measuredText : longestText;
				}
				//Add a little extra padding from the y axis
				longestText +=10;
			}
			xAxisLength = width - longestText - widestXLabel;
			valueHop = Math.floor(xAxisLength/(data.labels.length));
			barWidth = (valueHop - config.scaleGridLineWidth*2 - (config.barValueSpacing*2) - (config.barDatasetSpacing*data.datasets.length-1) - ((config.barStrokeWidth/2)*data.datasets.length-1))/data.datasets.length;

			yAxisPosX = width-widestXLabel/2-xAxisLength;
			xAxisPosY = scaleHeight + config.scaleFontSize/2;
		}
		function calculateDrawingSizes(){
			maxSize = height;

			//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
			ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
			widestXLabel = 1;
			for (var i=0; i<data.labels.length; i++){
				var textLength = ctx.measureText(data.labels[i]).width;
				//If the text length is longer - make that equal to longest text!
				widestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;
			}
			if (width/data.labels.length < widestXLabel){
				rotateLabels = 45;
				if (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){
					rotateLabels = 90;
					maxSize -= widestXLabel;
				}
				else{
					maxSize -= Math.sin(rotateLabels) * widestXLabel;
				}
			}
			else{
				maxSize -= config.scaleFontSize;
			}

			//Add a little padding between the x line and the text
			maxSize -= 5;


			labelHeight = config.scaleFontSize;

			maxSize -= labelHeight;
			//Set 5 pixels greater than the font size to allow for a little padding from the X axis.

			scaleHeight = maxSize;

			//Then get the area above we can safely draw on.
		}
		function getValueBounds() {
			var upperValue = Number.MIN_VALUE;
			var lowerValue = Number.MAX_VALUE;
			for (var i=0; i<data.datasets.length; i++){
				for (var j=0; j<data.datasets[i].data.length; j++){
					if ( data.datasets[i].data[j] > upperValue) { upperValue = data.datasets[i].data[j] };
					if ( data.datasets[i].data[j] < lowerValue) { lowerValue = data.datasets[i].data[j] };
				}
			};

			var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
			var minSteps = Math.floor((scaleHeight / labelHeight*0.5));

			return {
				maxValue : upperValue,
				minValue : lowerValue,
				maxSteps : maxSteps,
				minSteps : minSteps
			};


		}
	}

	function calculateOffset(val,calculatedScale,scaleHop){
		var outerValue = calculatedScale.steps * calculatedScale.stepValue;
		var adjustedValue = val - calculatedScale.graphMin;
		var scalingFactor = CapValue(adjustedValue/outerValue,1,0);
		return (scaleHop*calculatedScale.steps) * scalingFactor;
	}

	function animationLoop(config,drawScale,drawData,ctx){
		var animFrameAmount = (config.animation)? 1/CapValue(config.animationSteps,Number.MAX_VALUE,1) : 1,
			easingFunction = animationOptions[config.animationEasing],
			percentAnimComplete =(config.animation)? 0 : 1;



		if (typeof drawScale !== "function") drawScale = function(){};

		requestAnimFrame(animLoop);

		function animateFrame(){
			var easeAdjustedAnimationPercent =(config.animation)? CapValue(easingFunction(percentAnimComplete),null,0) : 1;
			clear(ctx);
			if(config.scaleOverlay){
				drawData(easeAdjustedAnimationPercent);
				drawScale();
			} else {
				drawScale();
				drawData(easeAdjustedAnimationPercent);
			}
		}
		function animLoop(){
			//We need to check if the animation is incomplete (less than 1), or complete (1).
				percentAnimComplete += animFrameAmount;
				animateFrame();
				//Stop the loop continuing forever
				if (percentAnimComplete <= 1){
					requestAnimFrame(animLoop);
				}
				else{
					if (typeof config.onAnimationComplete == "function") config.onAnimationComplete();
				}

		}

	}

	//Declare global functions to be called within this namespace here.


	// shim layer with setTimeout fallback
	var requestAnimFrame = (function(){
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) {
				window.setTimeout(callback, 1000 / 60);
			};
	})();

	function calculateScale(drawingHeight,maxSteps,minSteps,maxValue,minValue,labelTemplateString){
		var graphMin,graphMax,graphRange,stepValue,numberOfSteps,valueRange,rangeOrderOfMagnitude,decimalNum;
		
		valueRange = maxValue - minValue;
		
		rangeOrderOfMagnitude = Math.floor(Math.log(valueRange) / Math.LN10);
		graphMin = Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
		graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
		graphRange = graphMax - graphMin;
		stepValue = Math.pow(10, rangeOrderOfMagnitude);
		numberOfSteps = Math.round(graphRange / stepValue);
		
		//Compare number of steps to the max and min for that size graph, and add in half steps if need be.
		while(numberOfSteps < minSteps || numberOfSteps > maxSteps) {
			if (numberOfSteps < minSteps){
				stepValue /= 2;
				numberOfSteps = Math.round(graphRange/stepValue);
			}
			else{
				stepValue *=2;
				numberOfSteps = Math.round(graphRange/stepValue);
			}
		};


		var labels = [];
		populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue);
	
		return {
			steps : numberOfSteps,
			stepValue : stepValue,
			graphMin : graphMin,
			labels : labels
		}
	}

	//Populate an array of all the labels by interpolating the string.
	function populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue) {
		if (labelTemplateString) {
			//Fix floating point errors by setting to fixed the on the same decimal as the stepValue.
			for (var i = 1; i < numberOfSteps + 1; i++) {
				labels.push(tmpl(labelTemplateString, {value: (graphMin + (stepValue * i)).toFixed(getDecimalPlaces(stepValue))}));
			}
		}
	}
	
	//Max value from array
	function Max( array ){
		return Math.max.apply( Math, array );
	};
	//Min value from array
	function Min( array ){
		return Math.min.apply( Math, array );
	};
	//Default if undefined
	function Default(userDeclared,valueIfFalse){
		if(!userDeclared){
			return valueIfFalse;
		} else {
			return userDeclared;
		}
	};
	//Is a number function
	function isNumber(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	}
	//Apply cap a value at a high or low number
	function CapValue(valueToCap, maxValue, minValue){
		if(isNumber(maxValue)) {
			if( valueToCap > maxValue ) {
				return maxValue;
			}
		}
		if(isNumber(minValue)){
			if ( valueToCap < minValue ){
				return minValue;
			}
		}
		return valueToCap;
	}
	function getDecimalPlaces (num){
		var numberOfDecimalPlaces;
		if (num%1!=0){
			return num.toString().split(".")[1].length
		}
		else{
			return 0;
		}

	}

	function mergeChartConfig(defaults,userDefined){
		var returnObj = {};
		for (var attrname in defaults) { returnObj[attrname] = defaults[attrname]; }
		for (var attrname in userDefined) { returnObj[attrname] = userDefined[attrname]; }
		return returnObj;
	}

	//Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
	var cache = {};
	
	function tmpl(str, data){
		// Figure out if we're getting a template, or if we need to
		// load the template - and be sure to cache the result.
		var fn = !/\W/.test(str) ?
			cache[str] = cache[str] ||
			tmpl(document.getElementById(str).innerHTML) :
			 
			// Generate a reusable function that will serve as a template
			// generator (and which will be cached).
			new Function("obj",
				"var p=[],print=function(){p.push.apply(p,arguments);};" +
			 
				// Introduce the data as local variables using with(){}
				"with(obj){p.push('" +
			 
				// Convert the template into pure JavaScript
				str
					.replace(/[\r\t\n]/g, " ")
					.split("<%").join("\t")
					.replace(/((^|%>)[^\t]*)'/g, "$1\r")
					.replace(/\t=(.*?)%>/g, "',$1,'")
					.split("\t").join("');")
					.split("%>").join("p.push('")
					.split("\r").join("\\'")
			+ "');}return p.join('');");
	 
		// Provide some basic currying to the user
		return data ? fn( data ) : fn;
	 }
}